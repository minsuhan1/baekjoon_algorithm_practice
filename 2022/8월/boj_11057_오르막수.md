___
### 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
dp = [[0]*10 for _ in range(n+1)]
for i in range(10):
    dp[1][i] = 1

for i in range(2, n+1):
    for j in range(10):
        for k in range(j+1):
            dp[i][j] = (dp[i][j] + dp[i-1][k]) % 10007

print(sum(dp[n]) % 10007)
```
<br>

### 결과
![image](https://user-images.githubusercontent.com/50696567/186329849-f8b02bb0-ed1b-4d7c-b083-c0b8350c2e9b.png)

<br>

### 풀이 방법
- `다이나믹 프로그래밍` 활용
- `메모이제이션`의 기준을 N자리 수의 마지막 자리 수(j: 0~9) dp[n][j]로 정하였다.
- N자리 수의 마지막 자리 수가 j라면 그 앞 N-1자리에 올 수 있는 수는 마지막 자리 수가 j보다 작거나 같은 모든 N-1자리 수임을 활용하였다.
___
