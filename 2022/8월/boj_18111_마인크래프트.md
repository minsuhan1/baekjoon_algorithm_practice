___
### 코드
```python
from sys import stdin
import sys
input = stdin.readline

N, M, B = map(int, input().split())
graph = [list(map(int, input().split(' '))) for _ in range(N)]

min_time = sys.maxsize
min_time_height = 0

for target in range(257):
    # 채워야할 블록 개수, 제거해야 할 블록 개수 계산
    b_add = 0
    b_remove = 0
    time = sys.maxsize
    for i in graph:
        for j in i:
            if (target < j):
                b_remove += (j - target)
            if (target > j):
                b_add += (target - j)
    # 시간계산
    if (b_remove + B) >= b_add:
        time = b_remove * 2 + b_add
    if (time <= min_time):
        # print('time: ', time, 'min_time:', min_time, 'height:', target)
        min_time = time
        min_time_height = target

print(min_time, min_time_height)
```
<br>

### 결과
![image](https://user-images.githubusercontent.com/50696567/187337707-480502b3-2f9b-44ec-9732-2722117ea786.png)

<br>

### 풀이 방법
- `브루트 포스` 방식으로 해결하는 문제이다.
- 0부터 최대 높이 256까지 반복하면서, 높이가 target일 때 쌓아야 할 블록 개수와 제거해야 할 블록 개수를 계산한다.
- (제거하는 블록 개수 + 인벤토리 블록 개수) >= 쌓아야 할 블록 개수 인 경우 작업시간(time)을 계산하고 최소시간보다 작다면 최소시간을 업데이트한다.
- 0층부터 층수를 높여가며 반복하기 때문에 최소시간이 업데이트 될 때의 층수가 문제에서 최소시간이 같을 경우 원하는 최대층수이다.
- 백준 사이트에서 Python3로 제출한 경우 시간초과가 발생하였다. 대신 `PyPy3`를 사용하라는 조언을 보고 PyPy3로 제출하였더니 통과하였다.
- 반복이 많은 코드를 제출할 때에는 자주 쓰이는 코드를 캐싱하여 실행하는 PyPy를 사용하는 것이 시간을 줄이는 데 효과가 좋다고 한다. 대신 캐싱하기 때문에 이때 메모리는 더 사용한다.
- [PyPy와 Python을 비교한 참고자료] : https://ralp0217.tistory.com/entry/Python3-%EC%99%80-PyPy3-%EC%B0%A8%EC%9D%B4
___
