___
### 코드
```python
from sys import stdin
from collections import deque
import copy
input = stdin.readline

dx = [0,0,1,-1]
dy = [1,-1,0,0]

N = int(input())
graph = [list(input()) for _ in range(N)]
graph_w = copy.deepcopy(graph)    #적록색약
# 적색과 녹색은 같은 색으로 저장
for i in range(N):
    for j in range(N):
        if graph_w[i][j] == 'G' or graph_w[i][j] == 'R':
            graph_w[i][j] = 'A'
            

cnt = 0

def bfs(a,b,gr):
    queue = deque()
    queue.append((a,b))
    while queue:
        x, y = queue.popleft()
        
        color = gr[x][y]
        gr[x][y] = cnt

        if type(color) is not str:
            continue

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if 0 <= nx < N and 0 <= ny < N:
                if gr[nx][ny] == color:
                    queue.append((nx, ny))


for i in range(N):
    for j in range(N):
        if type(graph[i][j]) is str:    #방문하지 않은 좌표인 경우
            bfs(i, j, graph)
            cnt += 1

ans_1 = cnt

# 적록색약
cnt = 0

for i in range(N):
    for j in range(N):
        if type(graph_w[i][j]) is str:    #방문하지 않은 좌표인 경우
            bfs(i, j, graph_w)
            cnt += 1

ans_2 = cnt

print(ans_1, ans_2)
```
<br>

### 결과
![image](https://user-images.githubusercontent.com/50696567/188543843-a695c08a-6989-4c8d-9865-6b8e16e6bab7.png)

<br>

### 풀이 방법
- 인접한 4개 좌표의 색을 확인하며 같은 색의 구역을 체크하는 문제이므로 `BFS`를 활용하였다
- 큐에 저장된 좌표를 꺼내어 방문할 때마다 현재 구역의 번호 cnt를 좌표에 표시하여 방문처리를 했다
- 적록색약인 사람이 보는 좌표의 경우 처음부터 적색과 녹색을 'A'라는 같은 색으로 저장하였다
- 파이썬 깊은복사 : `copy.deepcopy(iter)`
___
